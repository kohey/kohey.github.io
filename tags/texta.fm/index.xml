<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>texta.fm on かわそんの掃き溜め</title>
    <link>https://kohey.github.io/tags/texta.fm/</link>
    <description>Recent content in texta.fm on かわそんの掃き溜め</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 12 Sep 2021 17:52:28 +0900</lastBuildDate><atom:link href="https://kohey.github.io/tags/texta.fm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RDSの歴史・immutability・validationについて</title>
      <link>https://kohey.github.io/post/ddd%E3%81%A8rdb%E3%81%AE%E8%B7%9D%E9%9B%A2/</link>
      <pubDate>Sun, 12 Sep 2021 17:52:28 +0900</pubDate>
      
      <guid>https://kohey.github.io/post/ddd%E3%81%A8rdb%E3%81%AE%E8%B7%9D%E9%9B%A2/</guid>
      <description>texta.fm#1・2からの学び
RDBが勢力伸ばした理由、immutability、validationについて。
RDBについて ORマッパー誕生の背景 ActiveRecordは、ORマッパーを構成するアーキテクチャパターン
ORマッパーはObjectモデルとRDSモデルの1:1のインピーダンスミスマッチを解消したかったから。
なんでRDSが勢力伸ばした？ インスタンスをDBにストアできれば一番ええやん？ =&amp;gt; OODB
これが一番マッピングもいらんからいいやん
RDBMS: 資金が潤沢に投入された &amp;amp; 背後の理論が純粋で強固だった =&amp;gt; RDBがOODBを上回った
Railsはデータモデリングが全て的なことがある。DB設計をバチっと決めたら全部上手くいくじゃん。
 immutabilityについて value obj が immutabilityを満たさないと、値の共有を安全にできなくなる。
value obj は値によって等価であるとみなすので、インスタンスが違っても同じになりうる。
メリット 普遍なので複数prop =&amp;gt; 組み合わせで状態を決定する =&amp;gt; 穴があるとおかしくなる =&amp;gt; このような状態が起こらないことを保証できる
目の前のことを信頼できる、ということ。 状態が確定している。
デメリット objは短命である場合、メモリの消費が増えること。
が、小さいobjをガンガン作って、ガンガン消していく、のは、obj志向プログラミングで一番想定されているので、問題なし。 Railsでreq -&amp;gt; res までに大量のsymbolを作成している。　1個のプロセスを効率よく使えれば、あとはスケールアウトさせるだけでは？
これはnodeのモデル
ムーアが頭打ちになってきている -&amp;gt; コアを並べてマルチにしよう -&amp;gt; いや、クラウド出てきた -&amp;gt; shared nothing のインスタンスを横に並べて、elastic にスケールさせた方がいいし、冗長性的にもいい。
 validationについて アサーションエラーと例外の使い分け
元々は画面に近い存在
契約による設計 ・アサーション(表明)
事前条件の契約 = 守らなかったら知らないぜ？
事前条件を満たしていないもの、あり得ないでしょ、という状態を弾く
・例外
あり得るものを弾く
防御的プログラミング 堅牢性を重んじるときにおきがち。</description>
    </item>
    
  </channel>
</rss>
